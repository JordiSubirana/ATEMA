struct FrameData
{
	mat4f proj;
	mat4f view;
	vec4f cameraPosition;
}

struct ObjectData
{
	mat4f model;
}

external
{
	[set(0), binding(0)] FrameData frameData;
	[set(0), binding(1)] ObjectData objectData;
	
	[set(1), binding(0)] sampler2Df materialColor;
	[set(1), binding(1)] sampler2Df materialNormal;
	[set(1), binding(2)] sampler2Df materialAO;
	[set(1), binding(3)] sampler2Df materialHeight;
	[set(1), binding(4)] sampler2Df materialEmissive;
	[set(1), binding(5)] sampler2Df materialMetalness;
	[set(1), binding(6)] sampler2Df materialRoughness;
}

[stage(vertex)]
input
{
	[location(0)] vec3f inPosition;
	[location(1)] vec3f inNormal;
	[location(2)] vec3f inTangent;
	[location(3)] vec3f inBitangent;
	[location(4)] vec2f inTexCoords;
}

[stage(vertex)]
output
{
	[location(0)] vec3f outPosition;
	[location(1)] vec2f outTexCoords;
	[location(2)] mat3f outTBN;
	[location(5)] vec3f outTanViewDir;
	[location(6)] vec3f outCameraPosition;
}

[entry(vertex)]
void main()
{
	vec4f worldPos = objectData.model * vec4f(inPosition, 1.0);
	vec3f worldNormal = normalize(objectData.model * vec4f(inNormal, 0.0)).xyz;
	vec3f worldTangent = normalize(objectData.model * vec4f(inTangent, 0.0)).xyz;
	vec3f worldBitangent = normalize(objectData.model * vec4f(inBitangent, 0.0)).xyz;
	
	outPosition = worldPos.xyz;
	
	outTBN = mat3f(worldTangent, worldBitangent, worldNormal);
	
	outTexCoords = inTexCoords;
	
	outTanViewDir = outTBN * (frameData.cameraPosition.xyz - worldPos.xyz);
	
	outCameraPosition = frameData.cameraPosition.xyz;
	
	vec4f screenPosition = frameData.proj * frameData.view * worldPos;
	
	setVertexPosition(screenPosition);
}

[stage(fragment)]
input
{
	[location(0)] vec3f inPosition;
	[location(1)] vec2f inTexCoords;
	[location(2)] mat3f inTBN;
	[location(5)] vec3f inTanViewDir;
	[location(6)] vec3f inCameraPosition;
}

[stage(fragment)]
output
{
	[location(0)] vec4f outPosition;
	[location(1)] vec4f outNormal;
	[location(2)] vec4f outColor;
	[location(3)] vec4f outAO;
	[location(4)] vec4f outEmissive;
	[location(5)] vec4f outMetalness;
	[location(6)] vec4f outRoughness;
}

vec2f parallaxMapping()
{ 
	float heightScale = 0.1;
	float minLayers = 8.0;
	float maxLayers = 64.0;
	float minDistance = 40.0;
	float maxDistance = 80.0;
	
	vec3f viewDir = normalize(inTanViewDir);
	
	float distanceFactor = clamp(distance(inCameraPosition, inPosition), minDistance, maxDistance + minDistance) - minDistance;
	distanceFactor = 1.0 - distanceFactor / maxDistance;
	
	minLayers = mix(1.0, minLayers, distanceFactor);
    maxLayers = mix(1.0, maxLayers, distanceFactor);
    float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));
	float layerDepth = 1.0 / numLayers;
	float currentLayerDepth = 0.0;
	
	vec2f S = viewDir.xy / viewDir.z * heightScale; 
    vec2f deltaUVs = S / numLayers;
	
	vec2f UVs = inTexCoords;
	float currentDepthMapValue = 1.0 - sample(materialHeight, UVs).r;
	
	while (currentLayerDepth < currentDepthMapValue)
    {
        UVs = UVs - deltaUVs;
        currentDepthMapValue = 1.0 - sample(materialHeight, UVs).r;
        currentLayerDepth = currentLayerDepth + layerDepth;
    }

	vec2f prevTexCoords = UVs + deltaUVs;
	float currentDepth  = currentDepthMapValue - currentLayerDepth;
	float prevDepth = 1.0 - sample(materialHeight, prevTexCoords).r - currentLayerDepth + layerDepth;
	float weight = currentDepth / (currentDepth - prevDepth);
	UVs = mix(UVs, prevTexCoords, weight);
	
	return UVs;
}

[entry(fragment)]
void main()
{
	vec2f texCoords = parallaxMapping();
	
	vec4f matColor = sample(materialColor, texCoords);
	vec3f matNormal = sample(materialNormal, texCoords).xyz;
	float matAO = sample(materialAO, texCoords).r;
	vec3f matEmissive = sample(materialEmissive, texCoords).rgb;
	float matMetalness = sample(materialMetalness, texCoords).r;
	float matRoughness = sample(materialRoughness, texCoords).r;
	
	outPosition = vec4f(inPosition, 1.0);
	
	vec3f normal = (matNormal * 2.0) - 1.0;
	normal = normalize(inTBN * normal);
	
	outNormal = vec4f(normal, 0.0);
	
    outColor = matColor;
    outAO = vec4f(matAO, matAO, matAO, 1.0);
    outEmissive = vec4f(matEmissive, 1.0);
    outMetalness = vec4f(matMetalness, matMetalness, matMetalness, 1.0);
    outRoughness = vec4f(matRoughness, matRoughness, matRoughness, 1.0);
}

